<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode104一棵树的最大深度</title>
      <link href="/2020/05/12/%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/2020/05/12/%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><p>   3<br>   /\<br>  9  20<br>     / \<br>   15   7<br>返回它的最大深度 3 。</p><hr><h2 id="dfs递归1"><a href="#dfs递归1" class="headerlink" title="dfs递归1"></a>dfs递归1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxn&#x3D;0;</span><br><span class="line">    void dfs(TreeNode* root,int k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root-&gt;left&#x3D;&#x3D;NULL&amp;&amp;root-&gt;right&#x3D;&#x3D;NULL) </span><br><span class="line">        </span><br><span class="line">         maxn&#x3D;max(maxn,k);</span><br><span class="line">        if(root-&gt;left)dfs(root-&gt;left,k+1); &#x2F;&#x2F;不能时k++</span><br><span class="line">        if(root-&gt;right)dfs(root-&gt;right,k+1);</span><br><span class="line">    &#125;</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">       </span><br><span class="line">        if(root&#x3D;&#x3D;NULL)return 0;</span><br><span class="line">       dfs(root,1);</span><br><span class="line">       return maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="dfs递归2"><a href="#dfs递归2" class="headerlink" title="dfs递归2"></a>dfs递归2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;NULL)return 0;</span><br><span class="line">        int ld&#x3D;maxDepth(root-&gt;left);</span><br><span class="line">        int rd&#x3D;maxDepth(root-&gt;right);</span><br><span class="line">        return max(ld,rd)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="bfs层次"><a href="#bfs层次" class="headerlink" title="bfs层次"></a>bfs层次</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">        if (root) q.push(root);</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            for (int i &#x3D; q.size() - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">                TreeNode* cur &#x3D; q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if (cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                if (cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这个循环特别重要</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode50-pow-x-n</title>
      <link href="/2020/05/11/leetcode50-pow-x-n/"/>
      <url>/2020/05/11/leetcode50-pow-x-n/</url>
      
        <content type="html"><![CDATA[<h1 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x,n)"></a>Pow(x,n)</h1><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p><p>示例 1:</p><p>输入: 2.00000, 10<br>输出: 1024.00000<br>示例 2:</p><p>输入: 2.10000, 3<br>输出: 9.26100<br>示例 3:</p><p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25<br>说明:</p><p>-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。  </p><a id="more"></a><hr><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>这里的x时int型，范围为（-2^-31,2^31-1）<br>我们使用的是当n为负值时直接去反，这样就会发生越界。所以要单独定义一个long long变量N来代替n，这也是一个比较常见的解决措施当面对这种大的负数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double qupow(double x,long long  n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)return 1.0;</span><br><span class="line">        double tem&#x3D;myPow(x,n&#x2F;2);</span><br><span class="line">        return n%2&#x3D;&#x3D;0?tem*tem:tem*tem*x;</span><br><span class="line">    &#125;</span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        long long N&#x3D;n;</span><br><span class="line">        if(n&lt;0) return 1.0&#x2F;qupow(x,-N);</span><br><span class="line">        else return qupow(x,N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1155heap-path</title>
      <link href="/2020/05/11/PAT1155Heap-paths/"/>
      <url>/2020/05/11/PAT1155Heap-paths/</url>
      
        <content type="html"><![CDATA[<h1 id="1155Heap-Paths"><a href="#1155Heap-Paths" class="headerlink" title="1155Heap Paths"></a>1155Heap Paths</h1><p>In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heap_(data_structure)</a>)<br>        <a id="more"></a><br>One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order.</p><p>Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.</p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line gives a positive integer N (1&lt;N≤1,000), the number of keys in the tree. Then the next line contains N distinct integer keys (all in the range of int), which gives the level order traversal sequence of a complete binary tree.</p><p>Output Specification:<br>For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree.</p><p>Finally print in a line Max Heap if it is a max heap, or Min Heap for a min heap, or Not Heap if it is not a heap at all.</p><p>Sample Input 1:<br>8<br>98 72 86 60 65 12 23 50  </p><p>Sample Output 1:<br>98 86 23<br>98 86 12<br>98 72 65<br>98 72 60 50<br>Max Heap  </p><p>Sample Input 2:<br>8<br>8 38 25 58 52 82 70 60  </p><p>Sample Output 2:<br>8 25 70<br>8 25 82<br>8 38 52<br>8 38 58 60<br>Min Heap  </p><p>Sample Input 3:<br>8<br>10 28 15 12 34 9 8 56  </p><p>Sample Output 3:<br>10 15 8<br>10 15 9<br>10 28 34<br>10 28 12 56<br>Not Heap  </p><hr><p>##题目大意：<br>给你n个数，然后通过层次遍历构成一颗二叉树。<br>你要从右到左输出每个从根到叶子的路径。并判断是最小堆，最大堆还是不是一个堆。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void dfs(int a[],int n ,string path,vector&lt;string &gt;&amp;res,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(k&gt;n) return;</span><br><span class="line">    if(k&lt;&#x3D;n)</span><br><span class="line">    &#123;</span><br><span class="line">        path+&#x3D;to_string(a[k]);</span><br><span class="line">        path+&#x3D;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(k*2&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        path.erase(path.length()-1);</span><br><span class="line">        res.push_back(path);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        dfs(a,n,path,res,k*2+1);</span><br><span class="line">        dfs(a,n,path,res,k*2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,ismax&#x3D;1,ismin&#x3D;1;</span><br><span class="line">    int a[1001];</span><br><span class="line">    string path;</span><br><span class="line">    vector &lt;string&gt;res;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for (int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot; %d&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(a,n,path,res,1);</span><br><span class="line">    for(auto it&#x3D;res.begin();it!&#x3D;res.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i&#x3D;2;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i&#x2F;2]&lt;a[i])ismax&#x3D;0;</span><br><span class="line">        if(a[i&#x2F;2]&gt;a[i])ismin&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ismax&#x3D;&#x3D;1)cout&lt;&lt;&quot;Max Heap&quot;;</span><br><span class="line">    if(ismin&#x3D;&#x3D;1)cout&lt;&lt;&quot;Min Heap&quot;;</span><br><span class="line">    if(ismax&#x3D;&#x3D;0&amp;&amp;ismin&#x3D;&#x3D;0)cout&lt;&lt;&quot;Not Heap&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown的基本语法</title>
      <link href="/2020/05/09/my-first-post/"/>
      <url>/2020/05/09/my-first-post/</url>
      
        <content type="html"><![CDATA[<h1 id="一：标题"><a href="#一：标题" class="headerlink" title="一：标题"></a>一：标题</h1><p>想要设置一个标题，可以用#来表示。<br>比如一级标题是#，二级标题是##，以此类推</p><h1 id="二：字体"><a href="#二：字体" class="headerlink" title="二：字体"></a>二：字体</h1><p>想要加粗字体，在字体两边分别用**包括起来。</p><p><strong>这个例子</strong><br>    <a id="more"></a><br>想要斜体，在字体两边分别用#包括起来。<br><em>这个粒子</em></p><p>想要斜体加粗，在字体两边分别用###包括起来。<br><strong><em>这个例子</em></strong></p><p>删除线，在文字两边用<del>包括起来<br>~</del>这是删除线~~</p><h1 id="三：引用"><a href="#三：引用" class="headerlink" title="三：引用"></a>三：引用</h1><p>在引用的文字面前加&gt;</p><blockquote><p>这是个例子</p></blockquote><h1 id="四：分割线"><a href="#四：分割线" class="headerlink" title="四：分割线"></a>四：分割线</h1><p> 例子：</p><hr><hr><h1 id="五：插入图片"><a href="#五：插入图片" class="headerlink" title="五：插入图片"></a>五：插入图片</h1><p>插入本地图片</p><p>！<a href shiyan\background.png"">faded</a></p><p>插入网站图片</p><p>![avatar]（图片地址‘图片title’）<br>例子如下：</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3Go1P.md.png" alt="fadad meomories"><br>#超链接</p><p>语法：</p><pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)  </code></pre><p>title可加可不加<br>例子：</p><p><a href="http://github.com/cczh" target="_blank" rel="noopener">我的GitHub</a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>用法：</p><p>单行代码：代码之间分别用一个反引号包起来</p><p><code>代码内容</code></p><p>代码块：</p><pre><code>（```）    code...    code...    code...(```)    </code></pre><p>例子：</p><p>单行代码</p><p><code>int main（）</code></p><p>代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;Hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
